### 图片的格式
#### 位图和矢量图
- 位图就是用像素点拼接起来的图片也叫做点阵图
- 矢量图不记录每一点的信息，而是记录元素形状和颜色的算法，软件对图形对应的函数进行运算，将运算结果图形的形状和颜色显示给你看
#### jpg/jped
- 采用jpeg格式压缩的图片
- 特点：有损压缩，直接色，位图，体积最小
- 常用于颜色要求丰富，无透明要求的
#### gif
- 图像装换格式 graphic interchange format，是一种位图图片格式，在1989年发布的89a版本才开始支持多帧动画和透明色
#### png
- 产生原因：unisys对gif格式的图片是有专利的，为了避免专利影响，改善并取代gif
- png8 特点：最多支持256色即索引色，无损，非动图可以替代gif，体积更小，对透明度支持高
- png24，特点：最多支持2^24色即直接色，无损，不透明，位图，但相同目标，png24是jpg的体积数倍
#### webP
- google发布的webp图片文件格式，同时支持有损和无损压缩。
##### 有损用来替代jpd
##### 无损来替代png
- webp支持Alpah透明，webp的无损压缩相对于png体积少了很多
##### 动态来替代gif
##### 优势
- webp拥有更有的图像数据压缩算法，在肉眼无法识别差异的图像质量的前提下，带来体更小的图片体积，同时具备了无损和有损压缩模式，Alpha透明和动画特性
- 缺点：兼容性不好


### <a href="./http2.md">http2</a>
- http2带来了传输性能的提升，核心是新的二进制分帧层，定义了如何封装http消息并在客户端与服务器之间传输

### 图片懒加载
#### 为什么要图片懒加载？
- 因为image（in viewport）的图片优先级为high，这些图片会占用其他资源的下载带宽，可能会造成其他关键资源（async xhr call） 加载缓慢，拖慢页面速度，同时可能用户不查看可视区域的图片，会造成加载资源的浪费
#### 实现
- 当页面加载时，只加载一个尺寸很小的占位placeholder 图片，然后再通过js去选择性的加载图片，只加载可视区域的内容，当页面向下滚动时，再继续加载后面的内容
- 实现方法：先不设置图片的src，而是将路劲放到一个特定属性中如（data-src），然后去监听scroll事件，当页面距离浏览器顶部的高度 小于或等于  当前可视窗口距离浏览器顶部的高度时，就去加载图片的src
#### **问题**
- 再图片懒加载时，由于图片的尺寸不定，浏览器难以计算需要给图片预留的位置，所以当图片加载完成后会造成页面的抖动，即使有placeholder图片，可以在毫秒内完成，也有可能会在网速慢的设备上造成页面抖动
- 可以设置一个占位符
`
.banner {
  height: 0;
  overflow: hidden;
  padding-bottom: 25.4%; // 计算图片的长宽比 这里就表示图片的高
}
.banner__img {
  width: 100%;
}`
- 可以使用intersection Observer
- 还可以加个防抖，防止监听scroll事件多次触发

### 缓存
- 配置强缓存和协商缓存
- CDN缓存

### 雪碧图
- 将多张比较小的图片，合并到一张大的图片上面，大的图片的背景是透明的，使用的时候通过不同的background-position定位来展示想要的那部分图片
#### 好处
- 将多次图片请求合并成一次请求，减少了网络请求，页面渲染速度加快，降低了服务器压力

#### 缺点
- 后期维护困难，每添加一张图片都需要重新制作
- 应用麻烦，每一张图都需要计算位置，通过调整位置来展示图片，对误差很严格
- 只能使用background-position来展示，不能使用img标签

#### 但是
- 在http1.1之后，前端就不必过多的关心http请求次数了
- 因为http1.1是默认开启长连接的，而且还拥有 管道机制，在同一个tcp连接中，可以传输多个http请求，多个请求和响应可以重叠

### 用iconfont取代小图标图片
- iconfont可以设置大小，颜色，css样式，同时还是矢量图

