#### 为什么需要有三次握手，二次不行吗，四次呢
##### 三次握手
1. 第一次握手：客户端给服务端发送一个SYN报文`客户端的初始序列号SN(c)`,此时客户端处于`SYN_SEND`状态
2. 第二次握手：服务器收到客户端发来的SYN报文，然后服务端发送一个SYN(服务器的初始序列号`ISN(s)`)+ACK(`SN(c)+1`)报文,ACK报文表明服务器已经收到客户端的SYN，此时服务器处于`SYN_RECV`状态
3. 第三次握手：客户端收到服务端发来的SYN+ACK报文，给服务端发送一个ACK(`ISN(s) + 1`)报文,ACK报文表明客户端已经收到服务器的SYN，此时客户端处于`establish`状态
4. 服务器收到ACK报文，此时服务器处于`establish`状态，连接建立

##### 为什么要三次握手
- 为了证明服务器和客户端拥有接收和发送的能力
1. 第一次握手，服务器知道了客户端有发送能力
2. 第二次握手，客户端知道服务器有发送和接收能力
3. 第三次握手，服务器知道客户端有接收和发送能力

##### 三次握手作用
1. 确认双方的接收能力和发送能力正常
2. 指定自己的初始序列化，为后面的可靠传输作准备
##### 二次不行吗
- 二次握手，服务器不能知道客户端是否有接收能力
- 为了防止已经失效的连接请求报文段突然又传送到B
  - `在只有二次握手的情况下`,当A给B发送第一个连接请求报文段，此时这个报文段在网络中滞留了，A又重新发出一个连接请求报文段，这个报文段成功到达服务器端，并且完成请求，断开连接，此时先前的第一个报文段的滞留一段时间后又到达了服务器，此时服务器就误以为这是A又发出的一次新的连接请求，于是向A发出确认报文段，同意确认连接，`在只有二次握手的情况下`，由于A没有发出建立连接的请求，所以不会理会B的确认报文段，但B却以为新的运输连接已经建立，并一直等待A发来数据,这样B的许多资源就浪费了
##### 四次不行吗
- 四次握手，3次握手已经证明双方都有发送和接收能力，再多一次是浪费网络资源和增加延迟

##### ISN的作用
- 可以通过ISN来确定数据传输是否乱序，tcp的数据片段中通过序列号来保证传输的数据可以按正常的顺序重组
##### ack确认号的作用
- tcp在传送一个数据包后，会把数据包放入重发队列，并启动一个计时器，如果收到确认号就会将数据包从队列删除，如果在计时器超时前还没收到确认号，则会重新发送数据包，超过最大重传次数，服务器会将此数据包从队列删除，每次等待重传的时间也不同，一般指数增长

##### ISN是固定的吗
- ISN是随机产生的，
- ISN = M + F
- M是一个计时器，每4ms+1
- F是根据源ip，目标ip，源端口，目标端口，用hash算法生成一个随机值，
- 最大值为0xFFFFFFFF,可能是0和4,294,967,295（2^32-1）之间的任意值,表示32位无符号10进制整数
##### 什么是半连接队列
- 在第二次握手后，服务器会处于`SYN_RECV`状态,服务器会把处于这种状态下的连接放在半连接队列

##### 三次握手中可以携带数据吗
- 在第三次握手中是可以携带的，因为此时客户端清楚服务器的接收和发送能力是正常的
- 第一次和第二次都是因为双方都不知道彼此的接收和发送能力如何
- 假如第一次握手可以携带数据，如果有人要恶意攻击服务器，他可以在第一次携带数据，迫使服务器要花费内存去存储这个数据包，疯狂发送SYN报文，会使服务器更容易遭受攻击

##### SYN攻击
- 客户端在完成第一次握手之后，拒绝给服务器发送ack报文段，迫使服务器不断重传第二次握手的报文段
- 可以减少SYN重传次数
- syn-cookie
#### 四次挥手
- 第一次挥手：客户端发送一个FIN报文，并在报文中指定一个序列号，仅仅代表客户端不会再发送数据报但还是会接收报文，此时客户端处于`FIN_WAIT1`状态
- 第二次挥手：服务器收到一个FIN报文，会发送一个ACK报文，值为客户端序列号+1，表示已经收到客户端的报文了（清楚客户端不会再发送数据，发送ACK是为了让客户端以为服务器收不到FIN报文，一直重复发FIN报文，为了让客户端闭嘴），此时服务器处于`CLOSE_WAIT`状态，客户端处于`FIN_WAIT2`状态
- 第三次挥手：服务器发送一个FIN报文，指定一个序列号，表示服务器已经不再发送数据，此时服务器处于`LAST_ACK`状态
- 第四次挥手：客户端收到FIN报文，会发送一个ACK报文（为了让服务器闭嘴），值为服务器序列号+1，此时客户端处于`TIME_WAIT`状态，需要过一段时间`2MSL`确保服务器收到自己的ACK报文才会进入`CLOSED`状态
- 服务器收到ACK报文就直接进入`CLOSED`状态
- 客户端处于`TIME_WAIT`状态，需要经过时间等待计数器设置的时间2MSL后，没有收到服务器再次发过来的FIN报文，才会进入`CLOSED`状态

##### 报文最大生存时间 MSL
##### 客户端通常主动执行关闭并主动进入`TIME_WAIT`状态，而服务器通常执行被动关闭，不会进入`TIME_WAIT`状态
##### 为什么不是3次挥手
- 假如是3次挥手，有2种情况
1. 第二次挥手和第三次挥手合并成一次挥手？
   - 服务器端在接收到客户端发送的FIN报文后，可能还有数据要处理发送，并不想断开连接，但又要让客户端知道服务器成功收到FIN报文，让客户端闭嘴，所以服务器发送了一个ACK报文
   - 等到服务器处理完数据，想要断开连接时才会发送FIN报文，所以第二次和第三次不能合并
2. 没有第四次挥手？
   - 如果没有第四次挥手，服务器就不知道客户端是否知道服务器想要断开连接，会重复发送FIN
   - 再经过2MSL后，没有答案就是答案了

##### 为什么是2MSL
- 2MSL的作用：用来确保没有任何属于当前连接的报文还存活在当前网络中
- 2MSL是从客户端收到FIN后发送ACK报文开始计时的,因为客户端不知道他的ACK报文何时到达服务器，所以客户端至少要维持1MSL的`TIME_WAIT`状态，才能确保它的ACK报文从网络中消失，同时处于`LAST_ACK`状态的服务器收到ACK报文，直接进入`CLOSED`状态，这样看`1MSL`是够的，但是在服务器收到ACK前的那一刻，服务器因为没收到ACK的报文所以重传了一个FIN报文，而这个FIN报文至少需要1MSL才能从网络中消失，所以客户端还需要等多1MSL，所以需要2MSL，相当于`至少允许报文丢失1次`
- 为什么不是4MSL 或 8MSL？
  - 4MSL就相当于连续丢包两次，在一个丢包率为百分之一的垃圾网络，连续丢包两次的概率是万分之一，解决这个问题性价比 比较低