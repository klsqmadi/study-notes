# 短连接
- 每一次http请求都会建立新的tcp连接（每一次http请求成功之后都会断开tcp连接）
# 长连接
- 只需建立一个tcp连接，每次http请求重复使用这个tcp连接，在数据传输完之后保持不断开tcp连接，等待同域名下继续使用该tcp连接
- 缺点：对于短连接浏览器可以通过连接是否关闭来界定请求或响应实体的边界，对于长连接浏览器不知道什么哪个是边界
- 解决方法：
- 1. content-length
- 2. 不依赖头部的长度信息，也能知道实体的边界。transfer-encoding：chunked
# 短轮询
- 通过递归的方式，每隔一段时间发送请求来获取数据是否更新，通过使用setTimeout和setInterval
- 缺点：
- 1.因为setTimeout和setInterval是宏任务，所以可能因为微任务和执行栈的阻塞，导致时间延后
- 2.固定频率的请求，可能数据没有更新，造成资源浪费
# 长轮询
- 服务器阻塞请求，不立刻返回数据，直到有数据了才返回给客户端，然后关闭连接，客户端处理完数据重新向服务器发送新的请求
- 一问一答
- 解决了频繁向服务器发送请求，浪费服务器资源
- 缺点：
- 保持连接会消耗资源
# iframe流
- 通过在页面插入一个隐藏的iframe，利用其src属性建立一个长连接，服务器向iframe传输数据，来实时更新页面，服务器返回数据跟jsonp差不多
- 缺点：ie firefox图表会一直转动，可以通过htmlfile解决
# comet
- 服务器推送的实现方式之一
- 1. 通过Ajax和长轮询来实现，
- 2. 通过iframe和htmlfile
# SSE
- SSE类似长轮询，区别是每一个连接不只是发送一个消息，客户端发送一个请求，服务器保持这个连接直到有新的消息发送回客户端，仍然保持着连接，这样连接就可以再次发送消息
- SSE还是利用http协议
- SSE本质不是发送一次性的数据包，而是一个数据流，会不断发送
- 适用于服务器向客户端单向发送消息
- 在客户端通过new Eventsource监听api，或者使用addEventlisenter监听
# websocket
- WebSocket协议是借用HTTP协议的101 switchprotocol(服务器根据客户端的指定，将协议转换成为 Upgrade首部所列的协议)来达到协议转换的，从HTTP协议切换成WebSocket通信协议。发起建立通过http主要是为了兼容性
- websocket是纯事件驱动，通过事件通知的方式运行的
- websocket基于tcp长连接建立连接进行握手
- 在进行数据交换时，需要传输的头部开销小，而http需要每次携带完整的头部
- 使用二进制帧，那么就可以使用多路复用

# websocket和长轮询的区别
- 长轮询就是客户端发起一个请求，然后服务器阻塞连接，等待有新的数据要发送了，才将数据返回回去，实际上还是一问一答的模式，底层还是http协议
- websocket通过http协议进行握手，握手成功之后就通过upgrade字段转换协议变成websocket，通过tcp长连接实现一个全双工通道，之后就与http协议无关了
- 长轮询是阻塞的i/o，而websocket是非阻塞i/o

# http2服务器推送
- 通过开发人员手动配置要具体随着某个请求推送一些资源
- 比如index.html，里面包含一个png图片，如果没有服务器推送，那么在返回index.html之后，浏览器发现还要请求png，还会再发送一个请求，有了服务器推送，服务器在返回index.html同时一起返回png图片
- 服务器推送在客户端是没有api可以去监听推送事件的