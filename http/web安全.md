#### 同源策略
- 浏览器只允许加载来自和自身同源的数据和资源，这可以解决大多数安全问题
- 源=协议+域名+端口号
##### CSP
- content security policy 内容安全策略，通过告诉浏览器一个规则，来只允许浏览器页面哪些**资源source**允许有哪些**源origin**，不在范围内的通通拒绝,比同源策略更严格
- 1. 通过服务器的响应头Content-security-policy来指定规则
- 2. 在html中添加meta标签来指定规则 http-equiv content=""
#### 跨域
##### JSONP
- JSON利用<script> 标签没有跨域限制的漏洞，可以得到从其他源获得的数据，不过这需要服务器的支持
##### cors
- 通过服务器设置Access-Control-Allow-origin，method，credential，表示哪些域名可以访问资源，这就等于让服务器来承担风险和责任了，不关浏览器的事情，所以服务器需要特别的去设置，不能设为*
- 通过这种方式解决跨域，在发送请求的时候会分为两种请求，简单请求和复杂请求
- 简单请求：同时满足
  - 请求方式为：get，head，post之一
  - content-type：text/plain ，application/x-www-form-urlencoded ，multipart/form-data之一
  - XMLhttprequest对象没有注册任何事件监听器
- 复杂请求：不是简单请求就是复杂请求了
- 对于复杂请求，浏览器在正式进行http通信发送请求之前会发送一个预请求，通过option方法，通过这个请求可以知道服务器是否允许跨域请求

##### postMessage
- postMessage允许来自不同源的脚本采用异步方式进行通信，可以实现跨文档，跨窗口，跨域消息传递
- 是HTML5新增的api
- 页面和新打开的窗口的数据传递
- 多窗口传递数据
- 页面和iframe的数据传递
- postMessage(message, targetOrigin, [transfer])

##### websocket
- 它实现了浏览器和服务器的全双工通信，websocket和http都是基于tcp协议的，在建立连接时websocket还是需要借助http

##### node代理
- 服务器和服务器之间通信是不需要跨域的，通过浏览器先向代理服务器发送请求，代理服务器再将请求转发到目标服务器，拿到结果后返回给浏览器，当然浏览器和代理服务器之间还是由跨域问题的，所以代理服务器需要解决跨域问题
  
##### nginx反向代理
- 原理和node代理差不多，也是通过nginx配置一台代理服务器，和浏览器通信也要解决跨域问题
- `/ proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;
    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}`
##### window.name + iframe
- 原理：name值通过url从一个页面加载切换到一个不同源的页面，name的值仍然不变，这样就可以通过iframe加载其他页面，拿到其他页面的name值
##### location.hash + iframe
##### document.domain
- 该方法只能由于二级域名相同情况下，比如a.test.cm  b.test.cm,通过js强制设置document.domain=test.cm为基础主域，实现同域
##### localStorage

#### xss攻击
- xss叫做跨站脚本 cross-site-script，简称css，通常是指通过网页开发时留下的**漏洞**，通过注入恶意代码到网页，使用户加载并执行含有恶意代码的网页,对用户浏览器进行控制或者获取用户数据
- xss的本质就是让对方的浏览器执行你插入的js代码
##### 类型
1. 反射型
   - 通过诱使用户点击一个恶意链接，xss代码出现在请求url中，作为参数提交到服务器中，服务器解析并响应，响应结果中包含xss代码，这是由于被攻击网站的网页漏洞，攻击者通过在url中插入xss代码，诱导正常用户去点击，然后被攻击网站解析url并返回一个含有xss代码的网页给正常用户，用户看到的就是一个包含有xss代码的不一定正常的网页。
2. 持久型
   - 攻击者通过表单提交恶意代码，通常在评论，电子邮件等，恶意代码会被存储到服务器，当其他受害者浏览含有恶意代码的网页时，网页就会执行恶意代码，然后恶意代码可能会窃取用户的数据发送到攻击者网站，或者冒充用户行为，调用网站的接口
3. DOM型
   - DOM型的原理和反射型一样，只不过在DOM型中，正常用户在点击恶意url后，用户浏览器收到响应后解析，前端js取出url中的恶意xss代码并执行，服务器并不参与

##### 防御手段
1. 输入过滤，前端对用户输入进行过滤，检查用户输入的一些特殊字符《》，后端也要进行过滤，因为可以绕过前端发送请求
2. 前端来防止浏览器执行恶意代码，前端在通过接口获取数据后，将代码和数据分隔开，由前端来告诉浏览器这个数据是文本节点，那个数据是属性，防止由浏览器自行解析数据
3. 输出检查，对服务器的输出也要进行编码或转义，转义意味着浏览器不会将其解释为HTML
4. http-only，防止通过js来获取cookie


#### csrf
- cross site request forgery ,跨站请求伪造，攻击者借助受害者的cookie骗取服务器的信任，在受害者毫不知青的情况下以受害者的名义伪造请求发送给服务器
- 攻击者通过恶意链接，诱导用户点击，点击之后在跳转到恶意网页，恶意网页会在用户不知道的情况下向一个正常网站发起请求，如果恰好该用户在这个正常网站登录过，同时保存着cookie，恶意代码就能以用户的名义去调用接口，而正常网站认为此次请求携带cookie，认为这次请求有效。
- 为什么能以用户的名义去调用接口？
- 因为浏览器判断需要携带哪个站点的cookie是看请求发往哪个站点，而不是看从哪个站点发出，所以在恶意网页的站点去请求正常站点，浏览器还是会携带的用户的cookie去调用接口

##### 特点
- 发生在 第三方 域名
- 攻击者不能获取 cookie 信息
##### 防御手段
- 同源检测，使用Origin Header确定来源域名，referer check：referer是http请求头的字段，它记录了该http请求的来源地址，通过这个字段，可以检查请求是否来自合法的源，但是referer可以被伪造
- 验证码，csrf通常是在用户不知情的情况下去发送请求，而验证码会强制用户必须与其进行交互，才能完成请求。但不能给所有接口都加上验证码，因此不能作为主要解决方案
- token，将cookie换成token来进行身份验证，因为攻击者不能获取cookie，但是浏览器会自动携带过去，而对于token来说，是前端人员在正常网页添加到请求头字段的，而攻击者获取不到token，所以可以防御csrf
- 避免全站通用的cookie，严格设置cookie的域

#### xss和csrf区别
- xss需要一个站点，csrf需要两个站点
- xss通过注入脚本来攻击，而csrf是通过冒用cookie来攻击

#### https

- 在第一次通信时**服务器**将他的**非对称公钥**发给客户端，客户端随机生成一把**对称加密的密钥**，然后客户端使用 `从服务器获取的非对称加密的公钥` 对 `客户端生成的对称加密 密钥` 进行加密（这里是非对称加密）并发给服务器，服务器用他自己的**非对称私钥**对客户端发来的**加密数据**进行解密，拿到客户端生成的 `对称加密的密钥`，然后双方用客户端生成的**对称加密的密钥**进行数据加密然后通信
- 但是上面再信息传输途中可以会被第三人劫持篡改，第三方冒充服务器跟客户端通信，又冒充客户端跟服务器通信（这就是中间人攻击），这就需要客户端去认证跟他通信的是不是服务器。
##### https传输过程
- 客户端发起https请求，服务端返回SS证书，客户端对证书进行验证，客户端对证书里面的**信息内容**通过散列算法hash得到摘要1，再用安系统自带的CA机构公钥对证书里面的数字签名进行非对称解密得到摘要2，将摘要1和摘要2进行对比，验证通过后本地生成用于改造对称加密算法的随机数，通过证书中的公钥对随机数进行加密传输到服务端，服务端接收后通过私钥解密得到随机数，之后的数据交互通过对称加密算法进行加解密
##### TS
1. 客户端问候消息：客户端通过向服务器发送“hello”消息来发起握手。消息中包含客户端支持的 TLS 版本、支持的密码套件（一组用于建立安全通信连接的加密算法），以及称为“客户端随机数”的一串随机字节。
 2. 服务器问候消息：作为对客户端问候消息的答复，服务器发送一条消息，内含服务器的 SSL 证书、服务器选择的密码套件，以及“服务器随机数”，即由服务器生成的另一串随机字节。
3. 身份验证：客户端通过 SSL 证书的证书颁发机构验证服务器的 SSL 证书。这将确认服务器确实是其声称的身份，并且客户端正在与域的实际所有者交互。
4. 预主机密：客户端再发送一串随机字节，即“ 预主机密”。预主机密使用公钥加密，并且只能由服务器使用私钥解密。（客户端从服务器的 SSL 证书获取公钥。）
5. 使用的私钥：服务器对预主机密进行解密。
6. 创建会话密钥：客户端和服务器均从客户端随机数、服务器随机数和预主机密生成会话密钥。它们应该得出相同的结果。
7. 客户端就绪：客户端发送一条“已完成”消息，该消息用会话密钥加密。
8. 服务器就绪：服务器发送一条“已完成”消息，该消息用会话密钥加密。
9. 实现安全对称加密：已完成握手，并且使用会话密钥继续进行通信。