#### http报文
起始行 + 头部 + 空行 + 实体
[https://blog.csdn.net/bijie6750/article/details/100950572?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.no_search_link&spm=1001.2101.3001.4242][http]
##### 请求报文
- <method> <request url> <http version> 回车符 换行符
- <headers> 回车符 换行符
- 空行（回车符 换行符）
- <entity body>
##### 响应报文
- <http version> <status> <reason-phrase> 
- <headers>
- 空行
- <entity body>

##### 作用
- reason-phrase 是对status更详细的描述
- entity-body 一个数据块，是可选的，可以为二进制或者文本


#### method
##### http0.9
- 只支持get命令传输简单文本
##### http1.0
- http1.0 新增了post head命令
- 增加响应体和请求头概念
- 任何类型都可以被传输，通过Content-type
- http1.0默认每一次http通信都是短连接，都需要经历tcp连接 传输数据 tcp连接断开 三个阶段
###### MIME类型
- 配置于content-type
- 浏览器通常用MIME类型来确定如何处理url，通常在`响应头`中添加MIME类型，如果配置不正确，浏览器会曲解文件内容，web无法正常工作，下载文件也会被错误处理
- MIME命名：类型 / 子类型
- 表示文本是普通文本 text/plain  text/html 
- 表示某种图像，包括动态图，但不包括视频image/jpeg   image/png 
- 表示某种音频文件 audio/mpeg audio/ogg
- 表示某种视频文件 video/MP4
- 表示二进制数据 application/javascript application/json，没有特定的或已知类型  可以使用application/octet-stream
- multipart类型 multipart/form-data boundary=aBoundaryString  这会变成分块传输，以--aBoundaryString 会边界线，此时content-length会被忽略
-  multipart/byteranges 用于将部分报文传回浏览器 当发送状态码206时，这个MIME类型用于指出这个文件被分为若干部分组成，通过content-type：boundary描写边界线，接下来的部分通过content-range来说明请求范围，通过content-type说明其文件类型
###### get和post区别
- get可以被缓存，保留在浏览器历史记录，长度限制，幂等，只能进行url编码，只能接收ascii码，参数放在url上，
###### head
- head跟get请求类似，但head的响应报文不会包含主体部分
- 使用head方法，可以在不获取资源的情况下去判断资源的类型，查看资源是否存在，查看资源是否被修改
- head返回的响应首部与get返回的一致
##### http1.1
- http1.1又新增了6个方法 put delete trace connect options patch
- http1.1默认了tcp是长连接，默认添加请求头connection：keep-alive，这也带来了一个报文在哪里结束，下一个报文在哪里开始的问题？定长数据通过content-length，不定长数据用transfer-encoding：chunked
- 引入管道机制：在同一个tcp连接中，可以传输多个http请求和响应，多个请求和响应可以重叠，但服务器还是按照顺序来处理请求，客户端也还是按照顺序来接收数据，这会带来队头阻塞的问题？
- 带宽优化方面：引入100 continue状态码，节约宽带，支持断点续传，通过range实现，返回206（partial content）
- 缓存处理方面：http1.0主要使用if-modified-since，expires来作为缓存判断，http1.1引入cache-control，entity tag，if-unmodified-since，if-match，if-none-match
- 引入host字段，
###### http1.1的缺点 
- 队头阻塞 无法解决，虽然可以通过创建多个域名分别向服务器发送请求，提高连接数
###### put
- 用于请求服务器在指定的位置创建文件，若存在文件则覆盖它
###### delete
- 请求服务器删除指定文件，当然是否删除由服务器决定
###### trace
- 客户端在发送请求后，经过网关，代理等，请求可能会被修改，服务器会在响应报文的实体中携带它收到最终收到的原始请求报文的样子，使用trace可以查看请求在最终到达服务器的样子
- 通常用于诊断一个请求是否到达服务器
###### connect

###### options
- options 通常用于去嗅探某个请求所对应的服务器支持哪种方法
- 一般情况下 都是浏览器去使用这个请求
- 简单请求：不会触发CORS预检请求的请求
- 复杂请求：会触发CORS预检请求
- 为什么浏览器要去发送这个options请求？？
![https://juejin.cn/post/6844904183905157127#heading-4](跨域)
![https://juejin.cn/post/6844904183905157127#heading-4](options)
- 这是因为在跨域情况下，跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。
##### http2.0
- http2.0最大的特点就是不会改动http语义，header字段，http方法，状态码，uri，主要是对http的传输性能进行改进
- http2.0是为了解决http1.1的缺点：http1.1使用管道机制，但会带来队头阻塞，请求报文和响应报文首部信息冗余量大，数据没有压缩，导致数据的传输量大
- 二进制分帧：http1.1通过文本传输，http2.0在应用层和运输层中加入一个二进制分帧层，在二进制分层上，http2.0会将所有传输的信息切割成更小的信息和帧，并采用二进制编码，首部信息会被封装到header帧，request body会被封装到data帧，每个帧都有一个标识符，这些帧可以乱序发送，到达之后再根据标识符进行组装
- 为什么会引入二进制分帧，
- 1. 因为在http1.1是基于文本分割解析的协议，服务器在接收解析数据时是通过不断的读入字节，然后判断是否有换行符/n,/r/n，这种方式的缺点是一次只能处理一次请求或响应，因为这种以分隔符分割消息的数据，在解析完成之前不能停止
- 2. 服务器解析这种数据无法预知需要多少内存，所以在分配内存上会给服务器带来很大压力，因为在解析一行数据时，在保证解析效率和速度的前提下，如何分配内存
- http2同域名的通信都是在同一个tcp连接下完成的，每个tcp连接都可以承载任意数量的双向数据流，每个数据流都是通过消息的形式发送，消息由一个帧或多个帧组成，
- 头部压缩：Hpack算法，维护一份索引表，在传输过程中使用索引来表示信息，首先，消息发送和接收端共同维护一份静态表和一份动态表，每次发送时，发送方根据字典内容和哈夫曼编码压缩消息头部，接收方根据字典解码，并判断是否要更新动态表，上一次发送的两端都会记住发送过哪些首部，下一次发送只需要发送传输差异的头部，相同的数据直接通过索引表表示
- ，静态表：只包含常见的头部名称以及头部名称和值的组合(定义了61个header字段和index)，可以通过传输index来获取header的字段与值
- 动态表：最初是一个空表，每次解码头部时，动态维护，对于静态，动态字典中不存在的内容，还可以通过哈夫曼编码来减小体积，http2使用了一份静态哈夫曼表，需要内置在客户端和服务器中
- 多路复用：多路复用是建立在二进制分帧的基础上的，二进制分帧是把一个消息进行拆分，给拆分出来的帧带上一个编号，这样另一端收到帧之后可以根据编号对帧进行组装，而多路复用就是可以同时发送多个消息拆分出来的多个帧，发起多个流，而且这些帧可以乱序发送，因为他们都有自己的编号，互不影响
- 请求优先级：发送方可以对要发送的帧带上优先级信息来对流标记优先级，优先级的目的是允许终端表达它如何对等端管理并发流时合理分配资源，优化这些帧的交错和传输顺序，优化性能
- 服务器推送：服务器可以对客户端的一个响应，返回多个数据，因为服务器知道客户端可能会使用这些东西，这样也加快了页面响应，减少数据传输冗余步骤

##### http3
- 
#### URI
- URI就是一个抽象定义，不管用什么办法实现，只要能定位一个资源，就叫做URI的实现，URL也只是URI标识资源的一个地址方式
- URL = protocol  :// user:passwd@ host:port path ? query #fragment
- URN 就是用名字来标识一个资源
##### URI编码
- RFC规定URL必须只能用英文字符 数字和某些标点符号，不能使用其他文字和符号，这意味着，如果url中含有汉字，就必须要进行编码才能使用，但是RFC又没有规定具体的编码规则，而是交由给浏览器实现，这导致编码规则很混乱，比如在Ajax调用中，ie使用GB2312编码，firefox使用utf-8编码
###### encodeURIComponent()
- 该方法不会对ascii的字符和数字进行编码，也不会对这个ascii标点符号进行编码`-_.!~*'()`,其他字符（比如 ：;/?:@&=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的
###### encodeURI()
- 对` , / ? : @ & = + $ #`这些特殊字符不会转义

###### escape()
- 对`* @ - _ + . /` 不会进行转义

###### 小结
- 对uri整个进行编码就用encodeURI
- 对uri的参数进行编码就用encodeURIComponent
- 对字符串进行编码就使用escape
#### osi7层模型
![osi7层](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/5/31/1726978d9f80a3df~tplv-t2oaga2asx-watermark.awebp)
##### 物理层
- 物理层最主要的功能就是负责在连接各种计算机的传输媒体中传输数据bit流
- 物理层连接方式有很多：点对点，多点连接，广播连接
- 物理层的传输媒体种类：架空明线，双绞线，对称电缆，同轴电缆，光缆，无线信道
###### 解决的主要问题
- 它关心的问题有：多少伏电压代表1？多少伏电压代表0？时钟速率是多少？采用全双工还是半双工传输？总的来说物理层关心的是链路的机械、电气、功能和规程特性。
- 物理层要尽可能的屏蔽掉物理设备和传输媒体，通信手段的不同带来的影响，使链路层感觉到因为介质不同产生的差异，应该让链路层只考虑本层的协议和服务
- 物理层为链路层提供在一条物理的传输媒体上传送和接收比特率的能力，所以物理层应该解决物理连接的建立和维持，释放的问题
##### 链路层
![链路层疑惑](https://www.codenong.com/cs106002439/)
- 链路层最主要的任务就是为网络层提供服务，保证将源计算机的网络层的数据可传输到相邻节点的目标计算机的网络层
- 解决两个相邻结点的通信问题
- 链路层主要功能有：如何将数据组合成帧，如何控制帧在物理信道上的传输，如何处理传输差错
- ppp,
###### 解决的主要问题
- 封装成帧：在物理层比特流的传输不能保证数据传输没有差错，为了实现数据有效的差错控制，所以使用了帧进行传输
- 透明传输：所有键盘输入的字符都可以放在帧中传输，这就是透明传输。当非ASCII码的文本时，数据中的某个字符恰好和帧定界符相同，链路层就会错误的找到帧的边界，而剩下的数据被丢弃，这样就不是透明传输。解决：发送端在数据中出现帧定界符的字符前加一个转义字符
- 差错检测：帧传输可能回出现帧丢失，帧重复，帧失序，所以加入帧编号，帧确认，帧重传。但现在广泛使用的链路层都不使用确认和重传机制
##### 网络层
- 进行逻辑地址寻址，实现不同网络之间的路径选择
- 网络层向上提供了一种尽最大努力交付的服务
- 网络层主要功能：转发，路由选择
- ip协议，icmp协议，arp协议
###### 解决的问题
- 地址管理：网络中的主机需要一种规则来区别，相当于身份标识，利用ip协议来每一台主机分配一个32位比特的标识符，所以有A类，B类，C类，在子网内还可以进行子网划分，网络号+子网号+主机号。
    - 通过ip地址可以找到目标路由器，但还需要找到目标主机，所以通过arp协议，对ip地址和mac地址的映射，然后找到目标主机，NAT转换表，arp协议只能在局域网只能进行广播
- 路由选择：从主机A到主机B，要跨过很多设备，数据在传输中需要选择的路径，通过路由算法找到距离最近的路由
- 当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。
##### 运输层
- 为上层提供提供端到端的可靠通信服务
- 定义传输数据的协议端口号，流量控制和差错校验
- 解决进程间通讯的问题，ip协议只能够完成定位主机，而tcp/ip协议能够完成进程建的通讯
- 通过tcp和udp
##### 会话层
- 负责应用程序之间建立，维持和中断会话，并提供访问验证和会话管理
- 使用校验点可使会话在通信失效时从校验点恢复通信
- 协议：RPC协议
##### 表示层
- 提供数据格式转换服务，浏览器请求回一堆数据，是解析成文本还是图片，由表示层决定
- 解密与加密，图片解码和编码，数据压缩和解压，例如：url加密，口令加密
- 协议由ASCII，SSL/TLS
##### 应用层
- 为操作系统或网络应用程序提供访问网络服务的接口，例如ftp，http，smtp
##### 为什么一般用的是5层，而OIS是7层
- 因为tcp/ip是先提出的，后才是ois
- 在RFC上一般是厂商先使用技术，而后才推出标准和理论
