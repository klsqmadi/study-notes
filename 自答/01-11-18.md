!(https://www.nowcoder.com/discuss/802459?type=post&order=create&pos=&page=1&ncTraceId=&channel=-1&source_id=search_post_nctrack)[海康视威]

1. js基本数据类型和复杂数据类型
- 基本数据类型又string number boolean undefined null Symbol BinInt
- 复杂数据类型 Object [Array，Object，Date，Map，Set，Function，RegExp]
- 基本数据类型的值是存储在栈里面的，跟变量一一对应，而复杂数据类型的值会存储在堆里面，然后把指向这个堆里面的值的指针存放到栈里面，跟变量一一对应，这样访问变量时，就会从栈取得指向这个对象的指针

- 为什么引入BigInt？因为JS的数字类型只支持双精度64位浮点数，而双精度64位浮点数他其中符号位占了1位，而指数位占了11位，指数位是为了特殊数字保留的，有效位数有53位，其中1位是隐式整数位的写入，所以双精度64位浮点数最大值是-2^53-1到2^53-1，那么如果超过这个范围，js就会进行四舍五入，所有有些超过这个范围的数字就会失去精度，在引入BigInt之前是通过使用字符串进行计算，因为字符串不会因为数字长度过长就失去精度，所以可以有效的计算大数，之后就引入BigInt解决这个问题

- 如何判断数据类型？
  - 1. typeof 
  - 2. instanceof,原理就是通过递归
  - 3. toString 
  - 4. 原型链判断，判断数据的原型和某个数据类型的prototype是否相等
  - 5. 通过constructor判断

2. 数组如何去重
- 1. for循环遍历，用map存储存在的值，每次去对比是否存在
- 2. for循环遍历，用indexOf / lastIndexOf查找，找到用splice删除
- 3. 双重for循环
- 4. 使用set去重，
- 考虑null, undefined NaN Object
- 使用Object.is()

3. js继承的8种方式
- 1. 原型链继承，缺点：多个子类会共享父类prototype的属性和方法
- 2. 构造函数继承，缺点：每次new子类实例时，都会调用到父类的call函数，相当于每次都将属性复制一份，而且只能继承到父类自身属性，不能继承父类prototype上的属性和方法
- 3. 组合式继承，缺点：会调用两次父类函数，造成new子类实例时，会出现实例一份属性，子类prototype上一份属性
- 4. 原型式继承：缺点：多个子类会共享父类prototype的属性和方法
- 5. 寄生式继承：缺点：不能传参
- 6. 寄生组合继承
- 7. extends

4. 作用域
- 作用域就是当前执行代码查找变量的权限
- 静态作用域 全局作用域 函数作用域 块作用域
- JS代码执行有3个阶段 (编译 预解析 执行)  
- 编译：词法分析  语法分析  代码生成
  - JS引擎：parser interpreter JIT compiler GC
  - 词法分析：JS引擎的parser会对代码进行词法分析，将一行代码分析成多个词法单元，比如(**var a = 2**);，就会分析成 `var a = 2 ；`
  - 语法分析：JS引擎的parser会将这些token词法单元转换成一个AST树
  - 代码生成：JS引擎的interpreter会将AST树转为字节码，然后等待解释执行字节码(`优化：运行时会收集函数的执行频率，对于到达一定阈值的热点代码，JIT compiler会将热点函数直接转换成机器码并缓存下来，然后直接执行`)
    - 为什么会有语法分析和代码生成这两个步骤？
      - 因为如果没有的话就每次执行都要检查语法和语义，每次结果都不被保留下来，都要重新编译分析，性能会受影响，转换成字节码，保证一次编译，多次运行时不需要校验
      - js是跨平台语言，而字节码是不依赖平台的，其他语言也可以转换成字节码
    - 为什么不直接编译成机器码？
      - 因为编译成机器码需要消耗大量时间，而且可能不是所有的代码会被执行到，所以编译成字节码，而且有JIT会进行优化
    - 什么是字节码？机器码？
      - 机器码就是计算机能读懂的语言，是一串cpu指令集，简单点就是给计算机执行的二进制代码，机器码是完全依附于硬件的，不同的硬件内嵌的指令集不同，即使相同的01代码意思也可能不同，所以机器码不具有跨平台性
      - 字节码是java语言特有的，是让jvm执行的二进制代码，不同的硬件只要通过jvm编译，所以具有跨平台性
- 预解析：对要执行的代码进行扫描，进行函数提升和变量提升，遇到函数，就对函数的执行上下文进行初始化，把变量对象，this，作用域[[scope]]进行初始化(将全局对象push到函数的scope里面)，挂载到全局对象上，遇到变量就进行变量提升
- 执行：
  - 1. 执行函数会创建一个函数的执行上下文，然后函数执行上下文被压入执行上下文栈，然后将函数的[[scope]]属性复制给函数执行上下文的scope(作用域)，
  - 2. 用arguments对象创建活动对象，然后形参，函数，变量声明，
    - 变量提升：
      - 1. 声明
      - 2. 初始化
      - 3. 赋值 
  - 3. 将AO活动对象压入执行上下文的scope中
  - 4. 开始执行函数，遇到变量，就会去执行上下文的scope里寻找是否有对应变量，如果没有，就继续在scope里面往上找，形成作用域链

5. 箭头函数和普通函数的区别
- 箭头函数自身的this指向是通过作用域链向外层查找来确定this的值的，所以也无法通过call，apply来改变this指向，同时也不能通过new去调用一个箭头函数
- 箭头函数没有prototype
- 箭头函数没有arguments对象，所以要访问形参要么通过指定变量来访问，要么通过扩展运算符来访问

6. let var const 区别
- let和const是拥有块级作用域，所以在{}里面通过let或者const定义一个变量，在外部是访问不到的，而var没有块级作用域这个概念，所以可以访问到
- let和const是不能重复声明的，如果重复声明一个变量，会提示报错，而var不会
- let和const是不会挂载到window对象上，而var会挂载
- let和const没有变量提升，变量提升有三个阶段：声明，初始化，赋值，而let和const在声明之后不会进行初始化，而是被到暂时性死区，而var会在声明之后进行初始化
- const声明的变量不能改变绑定，如果const声明的是基本数据类型，那么是不能被修改的，如果修改的是复杂数据类型那么就可以修改放在堆里的对象的值，但是不能修改存放在栈里的指针

7. 什么叫原型链
- 什么是原型？
  - 每个函数创建的时候它会有一个prototype属性
  - 假如没有prototype属性，那么每次new构造函数生成实例的时候都会复制一份属性，那么就会造成性能不好，有么有办法找个地方把一些相同方法放在一起，那样就可以一起调用，也不会占多个空间，那么就找一个空间，专门放置这些相同的方法，就是prototype了
  - 对象在使用属性时，如果在自身找不到属性，那么他就会往他的__proto__属性查找，如果还是没有继续，直到遇到null，这就是原型链

8. promise是什么？
- promise是ES6的一个新特性，他是解决异步流程控制的一个方案，异步流程控制就包括正常的数据流，异常数据处理，然后顺手解决了回调地狱的问题
- promise有3个状态，最开始是pending状态，结束状态时fullfiled或者rejected其中一个，而且状态是不可逆的
- 状态改变之后then方法的回调函数会被放入任务队列中，会被当做微任务去执行，为什么会被当做微任务执行呢，因为状态什么时候改变是由那么副作用函数去决定的，一旦改变状态，就可能需要去插队执行，所以宏任务的优先级比微任务低

9. generator是什么？
- generator是ES6的一个新特性，可以让我们暂停函数的执行并保留当前函数执行环境的功能，相当于交出函数的执行权
- generator是JS在语法层面对协程的支持，进程 线程 协程（线程的线程，对阻塞操作会放弃，并记录当前栈的数据，等到阻塞完成会重新调度协程去执行）

10. async await是什么
- 是generator和promise的语法糖，可以让我们用同步的写法去写异步写法
- 因为在promise中，我们是通过链式调用还操作异步流程的，他不是一种将异步转换成同步的方法，而是一种更好的编程风格而已，所以async，await可以帮助我们用将异步转成成同步写法

11. ES6特性
  1. 展开语法和收集语法
  2. set map symbol  weakSet weakMap
  3. 