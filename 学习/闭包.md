# 问题：说一下闭包
- 在js里，函数，块，模块都可以形成作用域（一个存储变量的空间），它们之间可以相互嵌套，作用域之间会形成引用关系，这条关系就叫作用域链
- js作用域是一个词法/静态作用域，在进行词法分析时就确定了作用域，所以叫做词法作用域
- js有一个特点就是可以return 函数，将函数作为返回值，所以导致了一个问题，本来是按顺序创建和销毁作用域的，但是如果内层函数返回出去了，那么外层函数销毁了，内层函数却没有销毁，这时候是怎么处理作用域的，父作用域销毁吗
- 不销毁父作用域不就好了吗？不行，因为可能有时候父函数里有大量变量未被子作用域引用到，变成无用变量，但却一直贮存在内存中，会造成性能问题
- 所以js会再创建一个对象，把子函数内引用父作用域的变量打包出来，给子函数打包带走
- 那打包出来的这个对象放到哪里呢，js用[[scope]]来存放，这是一个栈，销毁父作用域后，把用到的变量打包起来，打包给子函数，放到一个属性，这就是闭包的机制
- 闭包只保存外部引用，那么js怎么知道子函数引用到了哪个变量呢，就需要做AST扫描，很多JS引擎会去做lazy parsing，这时候去parse函数，就会知道它用到了哪些外部引用，然后把这些外部引用打包成closure闭包，放到[[scope]]上，所以闭包是返回函数的时候扫描函数内的标识符引用，做静态分析，把用到的外部引用打包成closure放到[[scope]],扫描到x个作用域，就会打包成x个closure
- 那js对eval会进行整个作用域打包，所以尽量不要用eval

### 闭包
- 每当创建一个函数，闭包就会在函数创建的同时被创建出来
- MDN定义:一个函数 和 对函数周围状态的引用 捆绑在一起构成闭包，可以让使用者从函数内部访问到外部函数的作用域
- 一个闭包就是一个持久的局部变量作用域
- 支持闭包的语言 允许你去保持对一个作用域的引用（包括它的父作用域）,即使声明变量的块已经完成执行，只要你对某处保留对该块或函数的引用
- 这让我们在其他的上下文调用该函数时，可以访问到该函数的作用域
- 通常一个函数结束时，它的所有变量都会消失，该函数的引用内存会被释放回收，但如果该函数返回一个内部函数然后保持这个内部函数的引用，使其函数不会被回收

### 作用
- 创建私有变量
- 延长变量的生命周期
- 避免全局变量的污染

### 缺点
- 变量不会被回收，常驻内存，增加内存使用量
- 使用不当造成内存泄漏