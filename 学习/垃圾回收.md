#### js的内存空间
- js的内存分为 栈，堆， 队列， 池
- 栈用于存放变量，基本类型数据和指向复杂类型数据的引用指针
- 堆用于存放复杂类型数据，是一种无序的树状结构，它还满足key-value键值对的存储结构，
- 队列在任务队列会用到
- 池又称常量池，用于存放常量

#### 垃圾回收
- ES并没有具体规定如何进行GC，所以如何实现垃圾回收具体是由引擎实现
- js中的内存管理是自动执行的,垃圾收集器会周期的回收那些不在继续使用的值
- 为什么需要垃圾回收：
  - 函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域也会随之销毁，其中包含的变量也会被统一释放回收，如果其中变量不被回收，必然会导致内存暴增，从而引发内存泄漏
  - V8引擎内存限制了堆内存的大小，在64位系统最多使用约1.4GB的内存，为什么要限制：
    - 起初只是作为浏览器端JavaScript的执行环境，在浏览器端我们其实很少会遇到使用大量内存的场景，因此也就没有必要将最大内存设置得过高。
    - js的单线程机制：每次执行垃圾回收时都会暂停js脚本，而且垃圾回收时非常耗时的操作
- v8的内存结构
  - v8把堆分成两个区域，一个是新生区new space，一个是老生区old space
  - 新生代：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，v8中的副垃圾回收器检测到from space空间即将到达上限，就会进行一次垃圾回收，新生区会使用scavenge算法，从根部root开始遍历，不可达对象将会被标记，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象（未标记的）复制过来。之后就将那一半剩下的内存清除，scavenge算法回收时会是一个同步操作，大概会阻塞1ms，在这个情况下，GC是一个整体操作，中间过程不会中断
  - 老生代：新生代中的对象在存活一段时间后（`应该是活过两次之后`）或者（当一个对象在复制到to space时，大于to space 25%）就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为`老生代指针区`和`老生代数据区`，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。老生区会使用mark-sweep（标记清除法） 和 mark-compace （标记压缩）。先进行mark操作，V8里使用的是三色算法，可被回收的对象标记为白色的，不可回收的对象标记为黑色，已被标记成可达对象但是还没扫描完标记为灰色，标记过的才能进行sweep 或 compact 操作，为什么会由compact出现，因为sweep最大的问题就是进行一次清除之后，内存空间会出现不连续的状态，
    - 大对象区：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区。
    - 代码区：代码对象，编译之后的代码会被分配在这里，唯一拥有执行权限的内存区域。
    - map区：存放对象的映射关系，其实就是隐藏类，加快对象的属性和方法在内存中的查找速度

- root根
  - 全局变量window，文档dom树，存放在栈上的变量
#### GC会在函数执行的时候进行垃圾回收吗
- 引擎会在堆上创建对象， 通常引擎在申请内存配置时，已分配内存不足的情况下会触发GC操作
- V8引擎在进行新生区 scavenge算法回收时会是一个同步操作，大概会阻塞1ms，在这个情况下，GC是一个整体操作，中间过程不会中断
#### 什么时候回收
- 
#### 算法

- 1.标记空间中可达值 
- 2.回收不可达值中所占据的内存 
- 3.做内存整理

- mark-sweep 标记-清除
  - 标记阶段：从根集合开始,将所有的活动对象即可达的打上标记
  - 清除阶段：遍历堆，将非活动对象（没有标记的）的连接到空链表上
  - 优点：实现简单，容易与其他算法结合0
  - 缺点：碎片化，会导致无数 小分块散落在堆的各处
  - 分配速度不理想，每次分配都需要遍历空闲列表找到足够大的分块
- mark-compact
- reference counting 引用-计数（2012年所有浏览器弃用）
  - 记录每个对象被引用的次数，每次新建对象，赋值引用和删除引用的同时更新计数器，如果计数器为0则直接回收内存
  - 优点：暂停时间短，可即刻回收垃圾，没必要沿指针查找，不用从root开始
  - 缺点：计数器的增减处理，计数器需要占用很多位，循环引用无法回收
- 分代收集
  - 浏览器将对象分为 临时对象 和 长久对象
  - 临时对象：函数内部声明的变量，通常容量小1-8M，存活时间短
  - 长久对象：window，dom，web api，对象占用空间大，存活时间长，使用标记-清除
  - V8将堆分为新生代 和 老生代 俩个区域，同时让副垃圾回收器负责新生代垃圾回收，主垃圾回收器负责老生代垃圾回收
  - 主垃圾回收器：负责老生代的垃圾回收，有两个特点：对象占用空间大；对象存活时间长。多次**标记-清除**后，会产生大量不连续的内存碎片，需要进行内存整理。
  - 副垃圾回收器：新生代被分为两个区域：一半是对象区域，一半是空闲区域，新加入的对象都被放入对象区域，等到对象区域快满时会执行一i垃圾清理，先给对象区域所有东西都做标记，标记完成后，存活的对象被复制到空闲区域，并将他们有序排列一遍，此时空闲区域是有序的，不需要碎片整理，复制完成后，对象区域会和空闲区域进行对调，因为副垃圾回收器操作比较频繁，所以为了执行效率，一般新生区的空间会被设置得比较小。一旦检测到空间装满了，就执行垃圾回收。
  - 对象晋升
    - 当一个对象在经历多次复制之后依旧存活，在下一次垃圾回收时直接转移到老生代中，称为对象晋升
    - 晋升条件：1.是否经历多一次scavenge算法，2.To空间的内存占比是否超过25%
- 增量收集
  - 如果脚本中有许多对象，引擎一次性遍历整个对象，会造成一个长时间暂停。所以引擎将垃圾收集工作分成更小的块，每次处理一部分，多次处理。
    这样就解决了长时间停顿的问题。
- 闲时收集
  - 垃圾收集器只会在CPU空闲时尝试运行

#### 内存泄漏

1. 尽可能少创建全局变量，全局变量挂载在window，window作为根节点不会被回收
2. 手动清除定时器
3. 少用闭包
4. 清除DOM引用
5. 弱引用

