#### 什么是模块

- 将一个程序按照一定的规则封装成块，块内部的数据和实现是私有的，只是向外部暴露一些接口与外部其他模块通信

#### 为什么要模块化

- 避免命名冲突
- 更改的分离代码，按需加载
- 更高 复用性
- 高可维护性

#### 模块化发展

- 1.无模块化的原始时代，直接在script写代码，但带来了问题就是**如果合作开发，大家都是在共同的一个作用域里，会产生命名冲突，模块成员看不出直接依赖关系**
- 2.namespace模式，简单对象封装，减少了全局变量，解决了命名冲突，但是又有问题：外部可以修改内部的数据
- 3.**IIFE模式**匿名函数自调用（闭包）,解决了外部修改内部数据问题，同时暴露出接口给外部，当前模块引入另外一个模块可以通过传参，**这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显**，但是又有问题：引入多个<scrpit>，在请求网页时，需要请求多个script，依赖模糊，我们很难记得它们的具体依赖关系是什么，可能导致加载顺序出错

##### commonjs

- 分为三个部分：require export moodule，每个单独的module是一个单独的作用域

- 由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，**如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范**

- CommonJS模块的加载机制是，输入的是被输出的值的浅拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值
- CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作

##### AMD

- require()函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。
- **AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块** 
- AMD和common 都是运行时加载
- AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中

##### CMD

- **CMD推崇就近依赖，只有在用到某个模块的时候再去require** 
- CMD支持动态引入

##### UMD

- umd是AMD和CommonJS的糅合

- UMD先判断是否支持Node.js的模块（exports）是否存在，存在则使用Node.js模块模式。

  在判断是否支持AMD（define是否存在），存在则使用AMD方式加载模块。

##### ES6模块

- 编译时加载
- ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。所以说ES6是**编译时加载**，不同于CommonJS的运行时加载(实际加载的是一整个对象)，ES6模块不是对象，而是通过export命令显式指定输出的代码
- 当require path模块时，其实 CommonJS会将path模块运行一遍，并返回一个对象，并将这个对象缓存起来，这个对象包含path这个模块的所有API。以后无论多少次加载这个模块都是取这个缓存的值，也就是第一次运行的结果，除非手动清除。
- ES6会从path模块只加载3个方法，其他不会加载，这就是编译时加载。ES6可以在编译时就完成模块加载，当ES6遇到import时，不会像CommonJS一样去执行模块，而是生成一个动态的只读引用，当真正需要的时候再到模块里去取值，所以ES6模块是动态引用，并且不会缓存值。
- CommonJS模块输出的是值的拷贝，所以当模块内值变化时，不会影响到输出的值。

