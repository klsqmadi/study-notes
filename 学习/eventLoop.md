# 大问题
1. js的编译流水线是什么样的
2. 渲染流程都做了什么
3. 为什么需要event loop
4. 不同的js宿主环境有什么不同
5. micro task 和 check都解决了什么问题
6. requestAnimationFrame 解决了什么问题
7. requestdleCallback是什么时候执行的

## js引擎的组成
- 虽然js是一个单线程的，但是指的是主线程只有一个，而浏览器是一个多进程应用
1. 网络进程
2. 浏览器进程
3. GPU进程
4. 插件进程
5. 渲染进程
   1. GUI线程
   2. JS主线程
      1. parser 编译器
      2. interpreter 解释器
      3. JIT compiler
      4. gc
   3. 定时器线程
   4. 异步http线程
   5. 事件触发线程
## eventLoop和js引擎，渲染引擎的关系
### js的编译
1. js引擎的编译发生在代码执行前的几微秒
2. js代码片段在执行前都要进行编译，整个流程分为词法分析，预编译，解释执行
3. 流程：parser首先进行词法分析，将代码分解成词法单元，然后将词法单元解析成一个AST树结构，之后AST转为字节码，解释执行字节码，运行时会收集函数执行的频率，对于到达了一定阈值的热点代码，会把对应的字节码转成机器码（AIT），然后直接执行不需要再进行字节码解释，
4. 预编译会对要执行的代码进行扫描，创建一个全局执行上下文，在全局作用域下，查找函数声明，创建函数的执行上下文（变量对象（初始化只有argument对象），this，作用域链scope），作为全局对象的属性，值赋予函数体，将global作用域push赋给函数的[[scope]]属性，查找变量声明，赋值为undefined
5. 执行：执行函数时，会创建一个执行上下文，将执行上下文推入执行上下文栈，进入执行上下文会激活变量对象，成为活动对象，然后进行hoisting，形参声明，函数声明，变量声明，然后执行代码
6. 渲染引擎：渲染时会把html，css分别用parser解析成dom和cssom， 将dom树对应的样式合并到一起，生成render树，遍历生成的render树进行layout回流，根据视口具体的宽度，计算出它们在设备视口viewport的确切位置（绝对坐标）和大小，根据回流得到的几何信息，得到节点的绝对像素，将像素发送给GPU
7. GPU对页面进行渲染
#### js引擎只会执行js代码，渲染引擎只会布局和渲染，怎么综合两者
##### 多线程
- 分为多个线程，由主线程来负责ui的更新，其他逻辑放到别的子线程，然后完成以后在消息队列中放消息，主程序不断循环的取消息来执行
- 如果使用了多线程的架构，基本都是只能在一个线程中来操作ui，由别的线程来发消息到这边来更新，如果多个线程，会有一个消息队列和looper，消息队列的生产者是各个子线程，消费者是主线程
##### 单线程
- js最开始只是作为提交表单，是页面的附加品，不是要很复杂的计算量，就没有采用多线程架构，因为多线程架构就要考虑各种锁的。所以只在一个线程里进行dom操作和逻辑计算，因此渲染dom和js的计算是阻塞的
- 而js引擎只负责计算，渲染引擎只负责渲染页面，那他们两个怎么进行交流，就是通过eventloop
##### 宿主环境
- JS引擎并不提供eventloop，eventloop是宿主环境为了集合渲染和JS执行，为了处理JS执行时的高优先任务而设计的机制
- 宿主环境有浏览器， node， 跨端引擎，不同宿主环境的eventloop实现不一样
##### 浏览器loop
- eventloop是解决js单线程运行阻塞的一种机制
- ![https://pic1.zhimg.com/80/v2-9ba77b9d06590058a9c899605ff7078c_720w.jpg](eventloop)
- 浏览器执行一个js任务就是一个loop，每个loop结束会检测下是否需要渲染，是否需要处理worker消息，通过这种每次loop结束都check的方式来综合渲染，js执行，worker，让它们能在一个线程内得到执行（不过渲染线程不和js在同一线程，但是会相互阻塞），这样子就解决了渲染，JS执行，worker的调度问题
- 但是我们在任务队列中不断的放置任务，这样子来了一个优先级更高的任务，是不是要等到它之前的任务都被JS线程取完才能开始执行这个任务呢？
- 加上一个急事通道：micro task
- 还是每次从消息队列取一个任务去执行，执行完检查下要不要渲染，处理下worker消息，如果有micro task优先执行micro task
- js执行完所有微任务，开始渲染前会有一个生命周期，就是requestAnimationTime，在这里面做一些计算，能保证一定是渲染之前做的计算，所以requestAnimationTime既不是宏任务也不是微任务，是每次loop完成之后进行check渲染，发现需要渲染的之前执行的一个回调函数
##### eventloop的问题
- 虽然加入了worker，但主流的还是JS线程和渲染线程之间相互阻塞，所以会导致一个问题
- 每一帧的计算和渲染是有固定频率的，如果JS的执行时间过长，超过一帧的刷新时间，那么就会导致渲染延迟，这一帧的数据还没开始渲染，下一帧的数据开始渲染了
- 什么情况下会导致渲染延迟，在每个loop的check渲染之前都会可能导致，task，micro task， requestAnimationTime， requestdleCallback，这样等到check的时候发现要渲染了，再去渲染就晚了
- 所以主线程的JS代码不会做太多的计算，要做拆分
- 也可以通过浏览器提供的API在每帧间隔的时间来执行，这样就不会阻塞渲染了，所以有了requestdlsCallback